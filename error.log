0) Diagn√≥stico r√°pido (antes de mexer)

Liste rotas que explodem:

rg -n "router\.(get|post|put|patch|delete)\(" -S src | sort


Ache poss√≠veis imports/exports quebrados:

rg -n "module\.exports\s*=" -S src
rg -n "exports\." -S src
rg -n "require\(.+controller" -S src


Rode o servidor e confirme a pilha (voc√™ j√° tem): veja arquivo e linha exata no .routes.js.

Se esse invent√°rio apontar que os controllers n√£o exportam o que as rotas chamam, √© exatamente o bug.

1) Padronize a estrutura (por dom√≠nio)
/src
  /domains
    /customer
      customer.routes.js
      customer.controller.js
      customer.service.js
      customer.validation.js   (opcional)
    /dashboard
      dashboard.routes.js
      dashboard.controller.js
      dashboard.service.js
  /routes
    index.js
  /middlewares
    errorHandler.js
    asyncHandler.js
  /utils
    safeRouter.js
    apiClient.js
server.js


Regra de ouro: Routes s√≥ chamam Controllers; Controllers s√≥ lidam com HTTP; Services ficam com regra de neg√≥cio/DB.

2) Crie util de Router ‚Äú√† prova de erro‚Äù

Pegadinha cl√°ssica √© passar undefined como handler. Este wrapper falha no boot com mensagem clara:

// src/utils/safeRouter.js
const express = require("express");
const METHODS = ["get", "post", "put", "patch", "delete", "all", "use"];

function safeRouter() {
  const router = express.Router();
  for (const m of METHODS) {
    const orig = router[m].bind(router);
    router[m] = (path, ...handlers) => {
      handlers.forEach((h, i) => {
        if (typeof h !== "function") {
          throw new Error(`Router.${m}("${path}") handler[${i}] √© ${typeof h}; expected function`);
        }
      });
      return orig(path, ...handlers);
    };
  }
  return router;
}

module.exports = safeRouter;


Use esse safeRouter() em todas as rotas. Assim, qualquer undefined aparece cedo com stack √∫til.

3) Middleware padr√£o para async/erros
// src/middlewares/asyncHandler.js
module.exports = fn => (req, res, next) => Promise.resolve(fn(req, res, next)).catch(next);

// src/middlewares/errorHandler.js
module.exports = (err, req, res, next) => {
  console.error(err);
  const status = err.status || 500;
  res.status(status).json({ success: false, message: err.message || "Erro interno" });
};

4) Controller/Service de exemplo (modelo)
// src/domains/customer/customer.service.js
async function update(id, payload) {
  // TODO: trocar por acesso real (Sequelize/Prisma/etc.)
  // Ex.: return Customer.update(payload, { where: { id }, returning: true });
  return { id, ...payload, updatedAt: new Date().toISOString() };
}

module.exports = { update };

// src/domains/customer/customer.controller.js
const service = require("./customer.service");

async function updateCustomer(req, res) {
  const { id } = req.params;
  const data = await service.update(id, req.body);
  res.json({ success: true, data });
}

module.exports = { updateCustomer };

5) Rotas usando o safeRouter + asyncHandler
// src/domains/customer/customer.routes.js
const safeRouter = require("../../utils/safeRouter");
const asyncHandler = require("../../middlewares/asyncHandler");
const controller = require("./customer.controller");

const router = safeRouter();

router.put("/:id", asyncHandler(controller.updateCustomer));

module.exports = router;


Importante: controller.updateCustomer existe e √© fun√ß√£o. Se n√£o existir, o safeRouter grita no boot.

6) Carregador central de rotas

Automatiza a montagem e evita erro de caminho:

// src/routes/index.js
const path = require("path");
const fs = require("fs");
const safeRouter = require("../utils/safeRouter");

const router = safeRouter();
const domainsDir = path.join(__dirname, "..", "domains");

for (const entry of fs.readdirSync(domainsDir, { withFileTypes: true })) {
  if (!entry.isDirectory()) continue;
  const name = entry.name;
  const routeFile = path.join(domainsDir, name, `${name}.routes.js`);
  if (fs.existsSync(routeFile)) {
    router.use(`/${name}`, require(routeFile));
  }
}

// health
router.get("/health", (req, res) => res.json({ ok: true }));

module.exports = router;

7) Server unificado
// server.js
const express = require("express");
const routes = require("./src/routes");
const errorHandler = require("./src/middlewares/errorHandler");

const app = express();
app.use(express.json());
app.use("/api", routes);
app.use(errorHandler);

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => console.log(`üöÄ Server on :${PORT}`));

8) Cliente de API externa centralizado (opcional, mas recomendado)
// src/utils/apiClient.js
const axios = require("axios");

const api = axios.create({
  baseURL: process.env.EXTERNAL_API_URL,
  timeout: 10000,
});

api.interceptors.response.use(
  r => r,
  err => {
    const wrap = new Error(err.response?.data?.message || err.message);
    wrap.status = err.response?.status || 500;
    throw wrap;
  }
);

module.exports = api;

9) Valida√ß√£o de payload (ex.: Zod) ‚Äî evita handlers receberem lixo
// src/domains/customer/customer.validation.js
const { z } = require("zod");

const updateSchema = z.object({
  name: z.string().min(1),
  email: z.string().email().optional(),
});

function validateUpdate(req, res, next) {
  const parsed = updateSchema.safeParse(req.body);
  if (!parsed.success) {
    const err = new Error(parsed.error.issues.map(i => i.message).join(", "));
    err.status = 400;
    return next(err);
  }
  next();
}

module.exports = { validateUpdate };


Usando na rota:

const { validateUpdate } = require("./customer.validation");
router.put("/:id", validateUpdate, asyncHandler(controller.updateCustomer));

10) ESLint para pegar undefined/imports quebrados

Crie .eslintrc.json:

{
  "env": { "node": true, "es2022": true },
  "extends": ["eslint:recommended", "plugin:node/recommended"],
  "rules": {
    "no-undef": "error",
    "node/no-missing-require": "error",
    "node/no-extraneous-require": "error",
    "no-unused-vars": ["error", { "argsIgnorePattern": "^_" }]
  }
}


Scripts no package.json:

{
  "scripts": {
    "lint": "eslint src --ext .js",
    "start": "node server.js",
    "dev": "nodemon server.js"
  }
}

11) Smoke tests r√°pidos (Supertest)
// test/health.test.js
const request = require("supertest");
const express = require("express");
const routes = require("../src/routes");
const errorHandler = require("../src/middlewares/errorHandler");

function makeApp() {
  const app = express();
  app.use(express.json());
  app.use("/api", routes);
  app.use(errorHandler);
  return app;
}

test("GET /api/health", async () => {
  const app = makeApp();
  const res = await request(app).get("/api/health");
  expect(res.status).toBe(200);
  expect(res.body.ok).toBe(true);
});


Adicione mais testes por dom√≠nio depois da refatora√ß√£o b√°sica.

12) Roteiro de execu√ß√£o (para seu agente)

Criar src/utils/safeRouter.js, src/middlewares/asyncHandler.js, src/middlewares/errorHandler.js.

Reorganizar pastas dos dom√≠nios como na se√ß√£o #1.

Em cada *.routes.js:

Trocar const router = express.Router() por const router = safeRouter().

Garantir que todas as chamadas tenham handlers fun√ß√£o (se houver controller.algo, confirmar export).

Em cada *.controller.js:

Exportar objeto com fun√ß√µes: module.exports = { minhaFuncao }.

Nenhum module.exports = function () {} direto.

Em cada *.service.js:

Isolar regra de neg√≥cio/DB (sem req/res).

Criar ou ajustar src/routes/index.js (auto-load dos dom√≠nios).

Ajustar server.js para usar /api + errorHandler.

Subir o app localmente:

npm run lint
npm start
curl -s http://localhost:3000/api/health | jq


Testar rotas cr√≠ticas (exemplos):

curl -X PUT http://localhost:3000/api/customer/123 -H "Content-Type: application/json" -d '{"name":"Teste"}'


Se aparecer qualquer erro de ‚Äúhandler undefined‚Äù, o safeRouter vai apontar rota e m√©todo. Corrija o require/export do controller correspondente.

Comitar por m√≥dulo refatorado:

git add .
git commit -m "refactor(domains): padroniza routes/controllers/services + safeRouter"

13) (Opcional) Fail-fast geral ‚Äî verifica√ß√£o est√°tica de rotas

Se quiser travar o boot caso um dom√≠nio esteja sem *.routes.js:

// em src/routes/index.js, ap√≥s o for:
if (router.stack.length === 0) {
  throw new Error("Nenhuma rota registrada. Verifique estrutura de domains/*/*.routes.js");
}
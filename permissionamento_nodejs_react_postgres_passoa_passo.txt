
Permissionamento multi-tenant (Node.js + React + Postgres) — Passo a passo completo
Para: mestre
Objetivo: implementar um sistema de permissionamento multi-tenant com catálogo (modules → submodules → features → actions), entitlements por tenant, RBAC por tenant, overrides por usuário, visibilidade para upsell (cadeados), cache, auditoria e endpoints prontos para uso com frontend React.

Índice rápido
1. Visão geral e objetivos
2. Arquitetura (componentes)
3. Esquema de banco (Postgres) — SQL detalhado
4. Seeds iniciais (ações, módulos exemplos)
5. Migrations & boas práticas (Sequelize/SQL)
6. Backend (Node.js) — estrutura de pastas e responsabilidades
7. Endpoints (API) — contrato detalhado
8. Algoritmo de resolução de permissões (passo a passo + pseudocódigo)
9. Cache (Redis) e permVersion (invalidação)
10. Middleware de autorização e uso nas rotas
11. Frontend (React) — fluxos, hooks e componentes essenciais
12. UI Admin (Roles / Entitlements) — UX/fluxo de edição
13. Testes: unit/integration/E2E (cenários concretos)
14. Rollout / migração / estratégia de deploy
15. Observabilidade e métricas
16. Checklist de entrega
17. Próximos passos que eu posso gerar pra você

1) Visão geral e objetivos
- Ter catálogo fixo do produto (modules/submodules/features/actions).
- Mostrar todos os módulos no frontend (visibilidade para upsell). Os recursos não ativos aparecem com cadeado (locked=true) e não permitem ação.
- Entitlements por tenant (active / locked / hidden / trial) — definem o que a empresa contratou.
- RBAC por tenant: roles → role_permissions (feature × action × allow/deny).
- Overrides por usuário para exceções.
- Owner: full access dentro do que o tenant tem ativo.
- Superadmin: bypass configurável (geralmente true para suporte).
- Cache e permVersion: alta performance com invalidação explícita.
- Logs de auditoria sempre que roles/entitlements/overrides mudarem.

2) Arquitetura (componentes)
- Postgres (dados relacionais primários)
- Redis (cache de snapshot de permissões)
- Node.js (Express/Koa) — API + IAM service
  - IAM Service (lógica de resolução de permissões)
  - RoleService, EntitlementService, UserService, AuditService
- React (frontend) — store (Redux/Context), hooks, páginas Admin
- Jobs / PubSub (RabbitMQ, Redis Pub/Sub ou SNS) — para invalidar cache em escala
- Observability: Prometheus/Grafana, logs estruturados (ELK), Sentry

3) Esquema de banco (Postgres) — SQL detalhado
Observação: duas formas de gerar UUIDs no Postgres: gen_random_uuid() (pgcrypto) ou uuid_generate_v4() (uuid-ossp). Exemplo abaixo usa gen_random_uuid().

-- Habilitar extensão
CREATE EXTENSION IF NOT EXISTS pgcrypto;

-- Tenants (empresas)
CREATE TABLE tenants (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  name TEXT NOT NULL,
  plan_key TEXT,
  status TEXT NOT NULL DEFAULT 'active',
  perm_version BIGINT NOT NULL DEFAULT 1,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Users (usuários globais)
CREATE TABLE users (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  email TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  password_hash TEXT,
  is_superadmin BOOLEAN NOT NULL DEFAULT FALSE,
  created_at TIMESTAMPTZ DEFAULT now(),
  updated_at TIMESTAMPTZ DEFAULT now()
);

-- Relacionamento user <-> tenant (roles e ownership)
CREATE TABLE user_tenants (
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  is_owner BOOLEAN NOT NULL DEFAULT FALSE,
  PRIMARY KEY (user_id, tenant_id)
);

-- Catálogo: modules / submodules / features
CREATE TABLE modules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  key TEXT UNIQUE NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  visible BOOLEAN NOT NULL DEFAULT TRUE,
  sort_order INT DEFAULT 0
);

CREATE TABLE submodules (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  module_id UUID NOT NULL REFERENCES modules(id) ON DELETE CASCADE,
  key TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  sort_order INT DEFAULT 0,
  UNIQUE (module_id, key)
);

CREATE TABLE features (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  submodule_id UUID NOT NULL REFERENCES submodules(id) ON DELETE CASCADE,
  key TEXT NOT NULL,
  name TEXT NOT NULL,
  description TEXT,
  sort_order INT DEFAULT 0,
  flags JSONB DEFAULT '{}',
  UNIQUE (submodule_id, key)
);

-- Ações canônicas
CREATE TABLE actions (
  id SMALLINT PRIMARY KEY,
  key TEXT UNIQUE NOT NULL
);

-- Entitlements (o que a empresa tem)
CREATE TYPE entitlement_status AS ENUM ('active','locked','hidden','trial');
CREATE TYPE entitlement_entity AS ENUM ('module','submodule','feature');

CREATE TABLE tenant_entitlements (
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  entity_type entitlement_entity NOT NULL,
  entity_id UUID NOT NULL,
  status entitlement_status NOT NULL,
  source TEXT NOT NULL,
  metadata JSONB DEFAULT '{}',
  PRIMARY KEY (tenant_id, entity_type, entity_id)
);

-- Roles e permissões
CREATE TABLE roles (
  id UUID PRIMARY KEY DEFAULT gen_random_uuid(),
  tenant_id UUID REFERENCES tenants(id) ON DELETE CASCADE,
  key TEXT NOT NULL,
  name TEXT NOT NULL,
  is_system BOOLEAN NOT NULL DEFAULT FALSE,
  UNIQUE (tenant_id, key)
);

CREATE TABLE role_permissions (
  id BIGSERIAL PRIMARY KEY,
  role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  feature_id UUID NOT NULL REFERENCES features(id) ON DELETE CASCADE,
  action_id SMALLINT NOT NULL REFERENCES actions(id),
  allowed BOOLEAN NOT NULL,
  UNIQUE(role_id, feature_id, action_id)
);

-- associações de roles a usuários
CREATE TABLE user_roles (
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  role_id UUID NOT NULL REFERENCES roles(id) ON DELETE CASCADE,
  PRIMARY KEY (user_id, tenant_id, role_id)
);

-- Overrides por usuário
CREATE TABLE user_permission_overrides (
  id BIGSERIAL PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES users(id) ON DELETE CASCADE,
  tenant_id UUID NOT NULL REFERENCES tenants(id) ON DELETE CASCADE,
  feature_id UUID NOT NULL REFERENCES features(id) ON DELETE CASCADE,
  action_id SMALLINT NOT NULL REFERENCES actions(id),
  allowed BOOLEAN NOT NULL,
  UNIQUE(user_id, tenant_id, feature_id, action_id)
);

-- Audit logs
CREATE TABLE audit_logs (
  id BIGSERIAL PRIMARY KEY,
  created_at TIMESTAMPTZ NOT NULL DEFAULT now(),
  actor_user_id UUID REFERENCES users(id),
  tenant_id UUID REFERENCES tenants(id),
  action TEXT NOT NULL,
  resource TEXT,
  payload JSONB
);

-- Indexes uteis
CREATE INDEX idx_tenant_entitlements_tenant ON tenant_entitlements(tenant_id);
CREATE INDEX idx_role_permissions_role ON role_permissions(role_id);
CREATE INDEX idx_user_roles_user ON user_roles(user_id);
CREATE INDEX idx_user_overrides_user ON user_permission_overrides(user_id);

Observações sobre o esquema:
- tenant.perm_version é a versão global de permissões para invalidar snapshots (incrementar quando roles/entitlements/overrides mudarem).
- tenant_entitlements usa entity_type + entity_id (pode apontar para module/submodule/feature). Em consultas, procurar do nível mais específico para mais genérico (feature → submodule → module).

4) Seeds iniciais (exemplo prático)
- Popule a tabela actions com as ações canônicas:
INSERT INTO actions(id, key) VALUES
(1,'create'),(2,'read'),(3,'update'),(4,'delete'),(5,'export'),(6,'approve'),(7,'manage_permissions');

- Exemplo de catálogo mínimo (módulos/submodules/features):
  - Module: orders (Pedidos)
  - Submodule: management
  - Features: orders.manage, orders.board

Recomendo gerar seeds em arquivos de migration (Sequelize/Knex) para facilitar deploy.

5) Migrations & boas práticas (Sequelize)
[OBSERVATION by Gemini]:
- 2025-08-30: Gerada a migration '20250830000000-create-new-permission-schema.js' para criar todas as tabelas do novo esquema de permissionamento conforme a Seção 3 deste documento.
[OBSERVATION by Gemini]:
- 2025-08-30: Gerada a migration '20250830000001-drop-old-permission-tables.js' para remover as tabelas do esquema de permissionamento antigo.
- Use migrations transacionais (Sequelize supports transactions in migration scripts).
- Crie seeders para actions, módulos e features.
- Ao alterar catálogo (rename key), nunca sobrescreva a key: crie nova entrada e mantenha compatibilidade (ou faça migração de dados com script).
- Ao rodar migration que altera permissões, execute UPDATE tenants SET perm_version = perm_version + 1 para forçar invalidação.

6) Backend (Node.js) — estrutura de pastas e responsabilidades
[OBSERVATION by Gemini]:
- 2025-08-30: Removidos arquivos de modelo, middleware e domínio (controllers, services, routes) relacionados ao sistema de permissionamento antigo.
src/
  api/
    routes/
      iam.js
      roles.js
      users.js
  services/
    iamService.js         # monta snapshot e checagem
    roleService.js
    entitlementService.js
    auditService.js
    cacheService.js      # redis wrapper
  models/                # Sequelize models
  middlewares/
    auth.js
    requirePermission.js
  jobs/
    invalidation.js      # listener pub/sub para invalidar cache
  utils/
    sqlHelpers.js

- iamService funções principais:
  - buildSnapshot(tenantId, userId) → monta o JSON retornado por /iam/tree e grava em Redis.
  - checkPermission(tenantId,userId,featureKey,actionKey,context) → retorna {allowed, locked, reason}.
  - bumpPermVersion(tenantId) → incrementa tenants.perm_version e publica invalidation.

- cacheService:
  - getSnapshot(tenantId,userId,permVersion) e setSnapshot(..., ttl)
  - invalidateTenant(tenantId) publica mensagem para invalidar perm:{tenant}:*.

- auditService.log(actor, tenantId, action, resource, payload) grava em audit_logs.

7) Endpoints (contrato detalhado)
Autenticação: JWT (Bearer). JWT tem userId e tenantId (caso user pertença a vários tenants, selecione tenant em contexto). Sempre revalide no backend.

GET /iam/tree?tenantId=
- Auth: required
- Query: tenantId (opcional se inferido do token), userId opcional
- Response: o snapshot JSON (formato já mostrado). Inclui permVersion.

POST /iam/check
- Auth: required
- Body: { tenantId, userId, featureKey, actionKey, context? }
- Response: { allowed: boolean, locked: boolean, reason: string, permVersion }

Roles CRUD
- GET /iam/roles?tenantId= → lista roles do tenant
- POST /iam/roles → criar role { key, name } (só admins)
- PATCH /iam/roles/:id → editar name
- DELETE /iam/roles/:id → apagar (só se não usada)
- POST /iam/roles/:id/permissions → { featureId, actionId, allowed } — sobrescreve ou upsert

User role/overrides
- POST /iam/users/:id/roles → atribuir role
- DELETE /iam/users/:id/roles → remover role
- POST /iam/users/:id/overrides → criar override { featureId, actionId, allowed }

Entitlements admin (superadmin)
- POST /iam/entitlements → { tenantId, entityType, entityId, status, source, metadata }
- DELETE /iam/entitlements → remover entitlement (ou alterar status)

Outros
- GET /me → retorna user, tenantId selecionado, roles, permVersion.

Regra: sempre que endpoints de alteração mudarem roles/entitlements/overrides → chame bumpPermVersion(tenantId) e auditService.log().

8) Algoritmo de resolução de permissões (detalhado)
Entrada: { tenantId, userId, featureKey, actionKey, context }
Saída: { allowed: boolean, locked: boolean, reason: string }

Passo a passo (ordem precisa)
1. Superadmin global? — se users.is_superadmin === true → retornar { allowed: true, locked: false, reason: 'superadmin' } (ou aplique política de bypass configurável).
2. Resolver feature → id (SELECT id, submodule_id FROM features WHERE key = $1). Se não existe → allowed=false, reason='feature-not-found'.
3. Checar entitlement (feature/submodule/module)
   - Procurar tenant_entitlements para (tenantId, 'feature', featureId). Se existe:
     - hidden → devolver { allowed: false, locked: true, reason: 'hidden' }.
     - locked → { allowed: false, locked: true, reason: 'entitlement-locked' }.
     - active/trial → seguir prova.
   - Se não encontrou para feature → procurar submodule → module (herança). Se nenhum active encontrado → tratar como locked.
4. Owner do tenant? (SELECT is_owner FROM user_tenants) — se true → { allowed: true, locked: false, reason: 'owner' }.
5. Overrides por usuário: buscar user_permission_overrides WHERE user_id=.. AND feature_id=.. AND action_id=..
   - Se existe allowed=false → { allowed:false, locked:false, reason:'user-deny' }.
   - Se allowed=true → { allowed:true, locked:false, reason:'user-allow' } (por enquanto continue checando denies em roles se quiser política stricter — recomenda-se: user-deny > user-allow > role-deny > role-allow).
6. Roles do usuário
   - Buscar roles do user no tenant; para cada role, buscar role_permissions (feature, action).
   - Se qualquer role tem allowed=false (deny) → { allowed:false, locked:false, reason:'role-deny' }.
   - Se pelo menos uma role tem allowed=true → { allowed:true, locked:false, reason:'role-allow' }.
7. Default → negar: { allowed:false, locked:false, reason:'no-role' }.

Notas:
- deny tem precedência sobre allow quando conflitam.
- Owner e Superadmin são exceções.
- Entitlement locked vence tudo (não importa se role/override permitem) — esse é o cadeado de upsell.

Pseudocódigo simplificado (conceito)
async function checkPermission(tenantId, userId, featureKey, actionKey) {
  const user = await users.findById(userId);
  if (user.is_superadmin) return {allowed:true,locked:false,reason:'superadmin'};

  const feature = await features.byKey(featureKey);
  if (!feature) return {allowed:false,locked:false,reason:'feature-not-found'};

  const entitlement = await entitlementService.getEffectiveEntitlement(tenantId, feature);
  if (!entitlement || entitlement.status==='locked' || entitlement.status==='hidden')
    return {allowed:false,locked:true,reason: entitlement?.status || 'entitlement-missing'};

  const ut = await userTenants.get(userId, tenantId);
  if (ut?.is_owner) return {allowed:true,locked:false,reason:'owner'};

  const userOverride = await userOverrides.get(userId, tenantId, feature.id, action.id);
  if (userOverride) return {allowed:userOverride.allowed,locked:false,reason: userOverride.allowed ? 'user-allow' : 'user-deny'};

  const roles = await userRoles.list(userId, tenantId);
  for (const r of roles) {
    const rp = await rolePermissions.get(r.role_id, feature.id, action.id);
    if (rp?.allowed === false) return {allowed:false,locked:false,reason:'role-deny'};
    if (rp?.allowed === true) foundAllow = true;
  }
  if (foundAllow) return {allowed:true,locked:false,reason:'role-allow'};
  return {allowed:false,locked:false,reason:'no-role'};
}

9) Cache (Redis) e permVersion — estratégia prática
- Chave: perm:{tenantId}:{userId}:v{permVersion}
- Valor: snapshot JSON (conforme GET /iam/tree), TTL 5 minutos (falso-safe). Ideal: 1–15 minutos.
- PermVersion: coluna tenants.perm_version (bigint). Sempre que alterar roles/entitlements/overrides, execute numa transação:
  1. Apply DB changes
  2. UPDATE tenants SET perm_version = perm_version + 1 WHERE id = :tenantId (retorna novo valor)
  3. Publish perm-invalidate:{tenantId} (com novo permVersion)
- Invalidation: worker subscribes perm-invalidate:{tenantId} e remove chaves perm:{tenantId}:* do Redis (ou simplesmente deixa a chave antiga expirar e let frontend refresh by permVersion mismatch).
- Cache read:
  - Ao checkPermission, primeiro leia tenant.perm_version. Se snapshot exists with same version → use. Senao → rebuild snapshot e cache.

10) Middleware de autorização e uso nas rotas
- Middleware requirePermission(featureKey, actionKey):
  - Extrai tenantId e userId do request (auth middleware)
  - Chama iamService.checkPermission(tenantId,userId,featureKey,actionKey)
  - Se allowed → next(); else → if locked send 402 + payload de upsell else 403.

Exemplo de fluxo:
- Rota POST /orders → requirePermission('orders.manage','create') → handler

11) Frontend (React) — fluxos, hooks e componentes essenciais
Snapshot e Login
- Ao logar, backend retorna /me com tenantId, roles, permVersion. Frontend pede /iam/tree?tenantId e armazena o snapshot no store.

Estrutura do snapshot (resumida)
- { tenantId, userId, permVersion, generatedAt, summary:{isOwner,isSuperadmin,roles}, modules:[{moduleKey,name,status,locked,submodules:[{...features:[{featureKey,actions:[{actionKey,allowed}]}]}]}] }

Hooks
- usePermissions() → retorna snapshot do store, função can(featureKey, actionKey) que olha no snapshot (mapa internalizado para O(1)).
- useCan(feature, action) → retorna boolean (leva em conta owner flag).

Components essenciais
- ProtectedRoute → verifica can(read) para rota; redireciona ou mostra tela de upsell.
- ActionButton → usa useCan para renderar habilitado/desabilitado; se locked mostra ícone de cadeado e onClick abre modal de upsell.

Menu
- Render todos modules. Para cada module:
  - if (module.locked) → mostrar cadeado e uiHints.
  - else → mostrar normalmente, e dentro usar feature.actions para ativar botões.

Revalidação
- Quando o backend retorna permVersion diferente da armazenada, frontend deve recarregar snapshot (ou automaticamente após role/entitlement change response).

12) UI Admin (Roles / Entitlements) — UX e fluxo de edição
Roles page
- Lista roles do tenant (system roles destacadas)
- Botão Criar role → abre editor com matriz (feature × actions) filtrável por module/submodule
- Ao salvar: chamada POST /iam/roles/:id/permissions e backend executa bumpPermVersion.

Users page
- Edit user → multi-select roles + botão Overrides (modal com search por feature e toggle para cada action).
- Ao salvar override → backend grava user_permission_overrides, faz audit e bumpPermVersion.

Entitlements page (Superadmin / Owner)
- Grade com módulos e features → toggle active/locked/trial
- Exibir origem (plan, addon, manuel)
- Ao alterar: audit + bumpPermVersion

13) Testes: unit / integration / e2e (cenários concretos)
Unit tests (iamService.checkPermission)
- superadmin true -> allowed
- owner true + feature active -> allowed
- entitlement locked -> locked
- user override deny -> denied
- user override allow (role denies) -> allow? (depends policy; prefer user-deny > user-allow > role-deny > role-allow)
- role deny overrides role allow -> denied
- inheritance: module active but feature missing entitlement -> allowed

Integration tests
- endpoint POST /iam/check com combos reais no DB (seeds)
- middleware requirePermission protege rota

E2E
- Owner cria role e atribui ao user -> user consegue ação
- Alterar entitlement para locked -> user não consegue mais

14) Rollout / migração / estratégia de deploy
1. Seed catálogo (modules/features/actions) em staging, criar roles templates.
2. Implementar iam.check e GET /iam/tree; habilitar middleware em modo log-only (apenas loga discrepâncias) por 7–14 dias.
3. Corrigir gaps, ajustar roles e mapa de features.
4. Canário: habilitar enforcement para 5% tenants (tag em tenants), monitorar por 1 semana.
5. Expandir gradual até 100%.
6. Treinar suporte e vendas com mensagens e links de upsell.

15) Observabilidade e métricas (práticas)
- iam.check calls per second, p95 latency
- cache hit ratio for perm:{tenant}:{user}
- denies by reason (entitlement-locked, role-deny, user-deny, no-role)
- clicks on locked items (for upsell)
- audit logs per day

16) Checklist de entrega (executável)
- [ ] Migrations criadas e testadas (staging)
- [ ] Seeds (actions, catálogo mínimo)
- [ ] iamService implementado e coberto por unit tests
- [ ] Middleware requirePermission implantado em rotas críticas
- [ ] Endpoints admin (roles/entitlements/users) implementados
- [ ] Redis configurado e permVersion bump funcionando
- [ ] Frontend (snapshot + hooks + menu) integrado
- [ ] Modo log-only disponível e ativado em staging
- [ ] Monitoramento e alertas configurados

17) Próximos passos que eu posso gerar pra você (escolha uma):
- Gerar migrations SQL prontos (arquivo .sql) para rodar no Postgres (já com CREATE TABLE).
- Gerar Sequelize models + migrations (arquivos prontos) para colar no seu projeto.
- Gerar o serviço iamService.js em Node.js (skeleton + pseudocódigo com queries otimizadas).
- Gerar hooks React (usePermissions, useCan) e componentes ProtectedRoute, ActionButton.
- Gerar planilha CSV com a matriz feature × actions pronta para preenchimento.

Fim do documento.
